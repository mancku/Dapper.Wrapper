namespace Dapper.Wrapper
{
    using FastCrud;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.Logging;
    using SqlManager;
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Text.Json;
    using System.Threading.Tasks;

    public class DapperWrapperSqlManager : DapperWrapper
    {
        private readonly ILogger _logger;

        public DapperWrapperSqlManager(IConfiguration configuration, ILogger logger,
            string nameOrConnectionString, SqlDialect sqlDialect)
            : base(configuration, nameOrConnectionString, sqlDialect)
        {
            _logger = logger;
        }

        public virtual async Task<DbOperationResult<T>> InsertEntityAsync<T>(T entity, bool manageTransaction = true,
            bool throwOnError = true)
        {
            var methodDescription = GetMethodDescription<T>();
            return await this.ExecuteDbTransaction(methodDescription, entity, this.InsertEntityCallback,
                manageTransaction, throwOnError);
        }

        public virtual async Task<DbOperationResult<T>> UpdateEntityAsync<T>(T entity, bool manageTransaction = true,
            bool throwOnError = true)
        {
            var methodDescription = GetMethodDescription<T>();
            var result = await this.ExecuteDbTransaction(methodDescription, entity, this.UpdateEntityCallback,
                manageTransaction, throwOnError);
            return result;
        }

        public virtual async Task<DbOperationResult<T>> DeleteEntityAsync<T>(T entity, bool manageTransaction = true,
            bool throwOnError = true)
        {
            var methodDescription = GetMethodDescription<T>();
            var result = await this.ExecuteDbTransaction(methodDescription, entity, this.DeleteEntityCallback,
                manageTransaction, throwOnError);
            return result;
        }

        public virtual async Task<List<DbOperationResult<T>>> InsertEntitiesAsync<T>(List<T> entities,
            bool manageTransaction = true, bool throwOnError = true)
        {
            var methodDescription = GetMethodDescription<T>();
            var result = await this.ExecuteDbTransactions(methodDescription, entities, this.InsertEntityCallback, true,
                manageTransaction, throwOnError);
            return result;
        }

        public virtual async Task<List<DbOperationResult<T>>> UpdateEntitiesAsync<T>(List<T> entities,
            bool manageTransaction = true, bool throwOnError = true)
        {
            var methodDescription = GetMethodDescription<T>();
            var result = await this.ExecuteDbTransactions(methodDescription, entities, this.UpdateEntityCallback, true,
                manageTransaction, throwOnError);
            return result;
        }

        public virtual async Task<List<DbOperationResult<T>>> DeleteEntitiesAsync<T>(List<T> entities,
            bool manageTransaction = true, bool throwOnError = true)
        {
            var methodDescription = GetMethodDescription<T>();
            var result = await this.ExecuteDbTransactions(methodDescription, entities, this.DeleteEntityCallback, false,
                manageTransaction, throwOnError);
            return result;
        }

        public virtual async Task<bool> DeleteEntitiesByIdAsync<T>(IReadOnlyCollection<T> entities,
            bool manageTransaction = true) where T : BaseEntityWithAutoGeneratedId
        {
            var entitiesIds = entities.Select(x => x.Id).ToList();
            return await this.DeleteEntitiesByIdAsync<T>(entitiesIds, manageTransaction);
        }

        public virtual async Task<bool> DeleteEntitiesByIdAsync<T>(IReadOnlyCollection<int> entitiesIds,
            bool manageTransaction = true) where T : BaseEntityWithAutoGeneratedId
        {
            var methodDescription = GetMethodDescription<T>();
            var entityName = typeof(T).Name;
            var numberOfEntitiesToDelete = entitiesIds.Count;
            var timer = Stopwatch.StartNew();
            var result = false;
            try
            {
                FormattableString filter =
                    $"{nameof(BaseEntityWithAutoGeneratedId.Id):C} {entitiesIds.ConvertToSqlIn()}";
                var deleted = await this.BulkDeleteAsync<T>(filter);
                if (deleted != entitiesIds.Count)
                {
                    throw new Exception(
                        $"Trying to delete {numberOfEntitiesToDelete} {entityName}, but instead only {deleted} were deleted");
                }

                if (manageTransaction)
                {
                    this.CommitChanges();
                }

                result = true;
            }
            catch (Exception ex)
            {
                this.HandleSqlError<T>(ex, methodDescription, manageTransaction);
                result = false;
            }
            finally
            {
                this.LogExecutedFunction(result, methodDescription, timer);
            }

            return result;
        }

        private static string GetMethodDescription<T>([CallerMemberName] string methodName = "")
        {
            return $"{methodName} - {typeof(T).Name}";
        }

        private async Task<DbOperationResult<T>> ExecuteDbTransaction<T>(string methodDescription,
            T entity, Func<T, Task> callback, bool manageTransaction, bool throwOnError)
        {
            var timer = Stopwatch.StartNew();
            var result = false;
            try
            {
                await callback(entity);
                if (manageTransaction)
                {
                    this.CommitChanges();
                }

                result = true;
            }
            catch (Exception ex)
            {
                this.HandleSqlError<T>(ex, methodDescription, manageTransaction);
                if (throwOnError)
                {
                    throw;
                }

                result = false;
            }
            finally
            {
                this.LogExecutedFunction(result, methodDescription, timer);
            }

            return new DbOperationResult<T>(entity, result);
        }

        private async Task<List<DbOperationResult<T>>> ExecuteDbTransactions<T>(string methodDescription,
            List<T> entities, Func<T, Task> callback, bool shouldCheckForDuplicatedNames,
            bool manageTransaction, bool throwOnError)
        {
            if (!entities.Any())
            {
                return [];
            }

            if (shouldCheckForDuplicatedNames)
            {
                await this.CheckForDuplicatedNames(entities);
            }

            var dbOperationsResults = new List<DbOperationResult<T>>();
            var timer = Stopwatch.StartNew();
            try
            {
                foreach (var entity in entities)
                {
                    var operationResult = false;

                    try
                    {
                        await callback(entity);
                        operationResult = true;
                    }
                    catch (Exception ex)
                    {
                        operationResult = false;
                        var errorMessage =
                            $"Error on on {methodDescription} --> {JsonSerializer.Serialize(entity)}";
                        if (throwOnError)
                        {
                            this.HandleSqlError<T>(ex, methodDescription, manageTransaction);
                            throw new Exception(errorMessage, ex);
                        }

                        _logger.LogError(ex, errorMessage);
                    }
                    finally
                    {
                        dbOperationsResults.Add(new DbOperationResult<T>(entity, operationResult));
                    }
                }

                if (manageTransaction)
                {
                    this.CommitChanges();
                }
                return dbOperationsResults;
            }
            finally
            {
                var didFunctionSucceed = dbOperationsResults.All(x => x.Succeeded);
                this.LogExecutedFunction(didFunctionSucceed, methodDescription, timer);
            }
        }

        private void HandleSqlError<T>(Exception ex, string methodDescription, bool manageTransaction)
        {
            _logger.LogError(ex, $"PSQL '{methodDescription}' threw an exception. Entity Type: {typeof(T).Name}");
            if (manageTransaction)
            {
                this.RollbackChanges();
            }
        }

        private void LogExecutedFunction(bool didFunctionSucceed, string methodDescription, Stopwatch timer)
        {
            var resultValue = "NEGATIVE";
            if (didFunctionSucceed)
            {
                resultValue = "POSITIVE";
            }

            _logger.LogDebug("PSQL {Function} executed in {Milliseconds}ms with {Result} result.",
                methodDescription, timer.ElapsedMilliseconds, resultValue);
        }

        private async Task InsertEntityCallback<T>(T entity)
        {
            await this.InsertAsync(entity);
        }

        private async Task UpdateEntityCallback<T>(T entity)
        {
            var updated = await this.UpdateAsync(entity);
            if (!updated)
            {
                throw new Exception("Update result was false but didn't throw exception");
            }
        }

        private async Task DeleteEntityCallback<T>(T entity)
        {
            var deleted = await this.DeleteAsync(entity);
            if (!deleted)
            {
                throw new Exception("Delete result was false but didn't throw exception");
            }
        }
    }
}